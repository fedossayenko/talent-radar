// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x", "linux-musl-arm64-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Company Source model - tracks where company info was scraped from
model CompanySource {
  id             String   @id @default(cuid())
  companyId      String
  sourceSite     String   // dev.bg, company website, etc.
  sourceUrl      String   // URL where the data was scraped from
  lastScrapedAt  DateTime @default(now())
  scrapedContent String?  // Stored scraped content
  contentHash    String?  // Hash for change detection
  isValid        Boolean  @default(true) // Whether the source URL is still valid
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([companyId, sourceSite])
  @@index([sourceSite])
  @@index([lastScrapedAt])
  @@index([isValid])
  // Full-text search index for scraped content - REMOVED due to PostgreSQL 8KB index limit
  // Large HTML content causes "index row requires 116KB, maximum size is 8191" errors
  @@map("company_sources")
}

// Company model
model Company {
  id               String   @id @default(cuid())
  name             String
  website          String?  // Company's main website
  originalWebsite  String?  // Original company website (different from scraped site)
  description      String?
  industry         String?
  size             String?  // 1-10, 11-50, 51-200, 201-500, 501-1000, 1000+
  location         String?
  logo             String?
  founded          Int?
  linkedinUrl      String?  // LinkedIn company page
  githubUrl        String?  // GitHub organization
  employeeCount    Int?     // Number of employees
  lastAnalyzedAt   DateTime? // When AI analysis was last performed
  
  // Cross-site duplicate detection fields
  companyAliases   Json?    @db.JsonB // Array of all known company name variations
  
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  analyses     CompanyAnalysis[]
  vacancies    Vacancy[]
  sources      CompanySource[]

  @@index([name])
  @@index([industry])
  @@index([size])
  @@index([location])
  @@index([lastAnalyzedAt])
  @@index([companyAliases], map: "companies_aliases_gin_idx", type: Gin)
  // Full-text search indexes for PostgreSQL
  @@index([name, description], map: "companies_fulltext_name_desc_idx")
  @@map("companies")
}

// Company Analysis model
model CompanyAnalysis {
  id                     String   @id @default(cuid())
  companyId              String
  sourceSite             String?  // Which site the analysis came from (dev.bg, company website)
  
  // Legacy scoring metrics (kept for backward compatibility)
  cultureScore           Float?   // 0-10 rating for company culture
  retentionRate          Float?   // Employee retention percentage
  workLifeBalance        Float?   // 0-10 rating for work-life balance
  careerGrowth           Float?   // 0-10 rating for career growth opportunities
  salaryCompetitiveness  Float?   // 0-10 rating for salary competitiveness
  benefitsScore          Float?   // 0-10 rating for benefits package
  techCulture            Float?   // 0-10 rating for technical culture
  
  // Modern comprehensive scoring system (2025)
  overallScore           Float?   // 0-100 composite score from scoring algorithm
  scoringFactors         Json?    @db.JsonB // All individual scoring factors (24 metrics)
  categoryScores         Json?    @db.JsonB // 6 category scores (developer exp, culture, etc)
  industryPercentile     Float?   // 0-100 percentile rank within industry
  sizePercentile         Float?   // 0-100 percentile rank within size category
  scoringMetadata        Json?    @db.JsonB // Scoring version, confidence, data sources
  scoreStrengths         Json?    @db.JsonB // Top company strengths identified
  scoreConcerns          Json?    @db.JsonB // Areas of concern identified
  scoreRecommendations   Json?    @db.JsonB // Improvement recommendations
  scoreCalculatedAt      DateTime? // When the comprehensive score was calculated
  
  // Detailed analysis fields (using JSONB for better performance)
  pros                   Json?    @db.JsonB // JSON array of positive aspects
  cons                   Json?    @db.JsonB // JSON array of negative aspects  
  hiringProcess          Json?    @db.JsonB // JSON string of process steps
  techStack              Json?    @db.JsonB // JSON string of technologies
  benefits               Json?    @db.JsonB // JSON array of benefits offered
  interviewProcess       Json?    @db.JsonB // JSON string of interview process details
  growthOpportunities    Json?    @db.JsonB // JSON array of career growth opportunities
  companyValues          Json?    @db.JsonB // JSON array of company values/mission
  workEnvironment        String?  // Description of work environment
  
  // Meta information
  analysisSource         String   @default("ai_generated") // ai_generated, manual, scraped
  confidenceScore        Float?   // 0-100 confidence in analysis accuracy
  dataCompleteness       Float?   // 0-100 how complete the source data was
  recommendationScore    Float?   // 0-10 overall recommendation score
  rawData                Json?    @db.JsonB // JSON string of raw analysis data
  sourceDataSummary      String?  // Summary of what sources were used
  
  // Enhanced AI processing traceability (Phase 1: Pipeline transparency)
  cleanedContentForAi   String?  // Final cleaned text sent to AI models
  rawAiResponse         String?  // Unprocessed AI response (JSON string)
  aiProcessingSteps     Json?    @db.JsonB // Processing pipeline metadata and steps
  
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt

  // Relations
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([sourceSite])
  @@index([analysisSource])
  @@index([recommendationScore])
  @@index([cultureScore])
  @@index([confidenceScore])
  // AI processing traceability indexes (field-based for Prisma compatibility)
  @@index([rawAiResponse], map: "company_analyses_raw_ai_response_idx")
  @@index([cleanedContentForAi], map: "company_analyses_cleaned_content_idx")
  // Modern scoring system indexes
  @@index([overallScore])
  @@index([industryPercentile])
  @@index([sizePercentile])
  @@index([scoreCalculatedAt])
  @@index([overallScore, industryPercentile])
  @@map("company_analyses")
}

// Vacancy model
model Vacancy {
  id              String   @id @default(cuid())
  title           String
  description     String?
  requirements    Json?    @db.JsonB // JSON array of requirements
  location        String?
  salaryMin       Int?     // Use Int for currency (in cents)
  salaryMax       Int?
  currency        String?  // Currency code (USD, EUR, BGN, etc.)
  experienceLevel String?  // junior, mid, senior, lead, principal, entry, not_specified
  employmentType  String?  // full-time, part-time, contract, internship, freelance
  workModel       String?  // remote, hybrid, office, not_specified
  companyId       String
  sourceUrl       String?
  sourceSite      String?
  status          String   @default("active") // active, inactive, filled, draft
  postedAt        DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // AI-specific fields
  contentHash            String?  // SHA-256 hash for caching extracted content
  extractionConfidence   Float?   // AI confidence score (0-100)
  extractionMetadata     Json?    @db.JsonB // JSON metadata: source, model used, processing time, etc.
  qualityScore          Float?   // Overall quality assessment (0-100)
  rawContent            String?  // Original scraped content for reprocessing
  aiExtractedData       Json?    @db.JsonB // JSON of all AI-extracted structured data
  
  // Enhanced AI processing traceability (Phase 1: Pipeline transparency)
  cleanedContentForAi   String?  // Final cleaned text sent to AI models
  rawAiResponse         String?  // Unprocessed AI response (JSON string)  
  aiProcessingSteps     Json?    @db.JsonB // Processing pipeline metadata and steps
  
  // Enhanced structured fields from AI extraction
  responsibilities      Json?    @db.JsonB // JSON array of job responsibilities
  technologies         Json?    @db.JsonB // JSON array of technologies and tools
  benefits             Json?    @db.JsonB // JSON array of benefits and perks
  educationLevel       String?  // high_school, bachelor, master, phd, not_specified
  industry             String?  // Industry/sector
  teamSize             String?  // Team size if mentioned
  companySize          String?  // startup, small, medium, large, enterprise, not_specified
  applicationDeadline  DateTime? // Application deadline if specified

  // Cross-site duplicate detection fields
  externalIds          Json?    @db.JsonB // Site-specific job IDs: {"dev.bg": "job-123", "jobs.bg": "8102284"}
  scrapedSites         Json?    @db.JsonB // Track all sites where job was found with timestamps
  originalJobId        String?  // Original job ID from source site
  lastSeenAt           Json?    @db.JsonB // Last seen timestamp for each site

  // Relations
  company      Company         @relation(fields: [companyId], references: [id], onDelete: Cascade)
  scores       VacancyScore[]
  applications Application[]

  @@index([contentHash])
  @@index([extractionConfidence])
  @@index([qualityScore])
  // AI processing traceability indexes (field-based for Prisma compatibility) 
  @@index([rawAiResponse], map: "vacancies_raw_ai_response_idx")
  @@index([cleanedContentForAi], map: "vacancies_cleaned_content_idx")
  @@index([sourceSite])
  @@index([companyId])
  @@index([experienceLevel])
  @@index([employmentType])
  @@index([workModel])
  @@index([status])
  @@index([postedAt])
  @@index([salaryMin, salaryMax])
  @@index([title])
  @@index([location])
  @@index([originalJobId])
  @@index([externalIds], map: "vacancies_external_ids_gin_idx", type: Gin)
  @@index([scrapedSites], map: "vacancies_scraped_sites_gin_idx", type: Gin)
  // Full-text search indexes for PostgreSQL
  @@index([title, description], map: "vacancies_fulltext_title_desc_idx")
  @@index([requirements], map: "vacancies_requirements_gin_idx", type: Gin)
  @@index([responsibilities], map: "vacancies_responsibilities_gin_idx", type: Gin)
  @@index([technologies], map: "vacancies_technologies_gin_idx", type: Gin)
  @@map("vacancies")
}

// Vacancy Score model
model VacancyScore {
  id                    String   @id @default(cuid())
  vacancyId             String
  overallScore          Float?
  salaryScore           Float?
  locationScore         Float?
  companyScore          Float?
  roleScore             Float?
  techStackScore        Float?
  workLifeBalanceScore  Float?
  careerGrowthScore     Float?
  scoringCriteria       Json?    @db.JsonB // JSON object of criteria and weights
  scoredAt              DateTime @default(now())

  // Relations
  vacancy Vacancy @relation(fields: [vacancyId], references: [id], onDelete: Cascade)

  @@index([vacancyId])
  @@index([overallScore])
  @@index([scoredAt])
  @@map("vacancy_scores")
}

// CV model
model CV {
  id            String   @id @default(cuid())
  filename      String
  originalName  String
  mimeType      String
  size          Int
  path          String
  extractedText String?
  skills        Json?    @db.JsonB // JSON array of skills
  experience    Int?     // Years of experience
  education     Json?    @db.JsonB // JSON array of education
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  applications Application[]

  @@index([filename])
  @@index([mimeType])
  @@index([experience])
  @@map("cvs")
}

// Application model
model Application {
  id          String   @id @default(cuid())
  vacancyId   String
  cvId        String?
  status      String   @default("draft") // draft, applied, interview, rejected, offered, accepted, withdrawn
  appliedAt   DateTime?
  coverLetter String?
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  vacancy Vacancy @relation(fields: [vacancyId], references: [id])
  cv      CV?     @relation(fields: [cvId], references: [id])

  @@index([vacancyId])
  @@index([cvId])
  @@index([status])
  @@index([appliedAt])
  @@map("applications")
}